# STM32F072RBT6 Custom Bootloader üöÄ

## Overview
This project implements a **custom bootloader** for the STM32F072RBT6, enabling dynamic selection between multiple firmware images stored in flash. The bootloader accepts inputs (**1,2,3,4**) from UART RX (tested with Minicom) to load the corresponding firmware. If the **user button** is not pressed on reset, the bootloader skips execution, and the default firmware (which blinks **LD3**) runs automatically.  

## Demo Videos üé•
üîπ **Bootloader Switching Between Applications**  

https://github.com/user-attachments/assets/6a4843df-7626-44ca-8d22-ecfd783b1e58

üîπ **Default Application**  

https://github.com/user-attachments/assets/28c10977-9d8a-4b6a-8dab-a2a20c3ca114

## Bootloader Flow Chart and Memory Model of flash

<p align="center">
  <img src="https://github.com/user-attachments/assets/3ddd2915-21d2-4c03-87cf-d6a16f038900" alt="Untitled-2025-04-03-1539">
</p>

<p align="center">
  <img src="https://github.com/user-attachments/assets/2e93df75-f94a-4713-a469-198e3a79bb3c" alt="Image">
</p>



According to RM0091:

![image](https://github.com/user-attachments/assets/9aa97cca-b46a-4793-837f-eaa014152ea0)


The STM32F072RBT6 flash memory is organized into **2 KB pages**, with a maximum of **sector 31 (Page 63)**. This project strategically allocates flash to store the **bootloader, multiple firmware versions, and a shared function pointer struct** for common APIs. 


## Features
- ‚úÖ **Multi-application support** (Bootloader selects firmware based on user button conditions on reset)
- ‚úÖ **Interrupt handling via Bootloader's Vector Table**
- ‚úÖ **UART communication to control which application user wants to run**
- ‚úÖ **Function pointer-based API for shared services**
- ‚úÖ **Accurate Delay generated by SysTick timer**


## Challenges Faced & Solutions
### 1Ô∏è‚É£ **Handling Interrupts Without VTOR (Cortex-M0 Limitation)**
**Problem:** Cortex-M0 lacks the **Vector Table Offset Register (VTOR)**, making it difficult to relocate the vector table for different firmware images.

‚úÖ **Solution:** There are 2 ways to solve this either copy each firmwares vector table to SRAM or use bootloader vector table. Since this is a simple applciation i went with using the bootlaoders vector table as it was giving a stable output. when I copied VT to SRAM the application was not stable.

### 2Ô∏è‚É£ **UART TX Issue in Minicom (Hardware Flow Control)**
**Problem:** Minicom wasn‚Äôt transmitting data because **hardware flow control (CTS/RTS) was enabled**.

‚úÖ **Solution:** Disabling hardware flow control in Minicom resolved the issue, allowing TX (sending commands from keyboard of PC) to work correctly.

### 3Ô∏è‚É£ **Custom memory functions were not working as expected**
**Problem:** A **struct holding function pointers that point to commonly used functions accross all the firmwares** was stored in a shared memory region, but modifying the struct (e.g., changing order, adding/removing members) in the respective firmwares led to unpredictable function calls.

‚úÖ **Solution:** The struct definition must be **identical in both Bootloader and Firmware**. Function pointers inside a struct rely on a **fixed memory layout**. If the struct is modified inconsistently across firmware versions, the function pointers will point to **incorrect or invalid addresses**, leading to crashes or unexpected behavior.

## Build & Flash Instructions
Followed STM32CubeIDE build and flash process and debugged using the built in debug software.

## Contributing
Open to contributions! Feel free to **submit PRs** or open an **Issue** if you find something to improve. üöÄ

